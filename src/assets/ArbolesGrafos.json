[
    {
        "title": "Arboles",
        "sources": "Data Structures and Algorithms in C++ 2e \nEstructura de datos orient ... uardati-FREELIBROS.ORG",
        "data": [
          {
            "subtitle": "",
            "body": "Un árbol se puede definir como una estructura jerárquica y en forma no lineal, aplicada sobre una colección de elementos u objetos llamados nodos.  \nLos árboles son considerados las estructuras de datos no lineales y dinámicas de datos muy importantes del área de computación.  \nLos árboles son muy utilizados en informática como un método eficiente para búsquedas grandes y complejas.  \nCasi todos los sistemas operativos almacenan sus archivos en árboles o estructuras similares a árboles. \nSe les llama estructuras dinámicas, porque las mismas pueden cambiar tanto de forma como de tamaño durante la ejecución del programa. Y estructuras no lineales porque cada elemento del árbol puede tener más de un sucesor \n",
            "images": [
              "./assets/images/arbol.gif"
            ]
          },
          {
            "subtitle": "Arboles binarios",
            "body": "Un árbol binario es aquel es el que cada elemento apunta como máximo a otros 2 elementos, comúnmente llamados hijo izquierdo y hijo derecho.",
            "images": [
              "./assets/images/ARBOL ABB.png"
            ],
            "code": [
              {
                "title": "Arboles ejemplo",
                "code": "#include <iostream> \n#include <cstdlib> \nusing namespace std; \n \ntemplate <class T>\nclass ArbolBinario;\n\ntemplate <class T>\nclass NodoArbol{\n    private:\n        T info;\n        NodoArbol<T> *izq;\n        NodoArbol<T> *der;\n    public:\n        NodoArbol();\n        T getInfo();\n        ActualizarInfo(T);\n        friend class ArbolBinario<T>;\n};\n\ntemplate <class T>\nNodoArbol<T>::NodoArbol(){\n    izq = nullptr;\n    der = nullptr;\n}\n\nT NodoArbol<T>::getInfo(){\n    return info;\n}\n\nvoid NodoArbol<T>::ActualizarInfo(T dato){\n    info = dato;\n}\n\ntemplate <class T>\nclass ArbolBinario{\n    private:\n        NodoArbol<T> *Raiz;\n    public:\n        ArbolBinario();\n        CrearArbol(NotoArbol<T>);\n        Preorder(NotoArbol<T>);\n        Inorder(NotoArbol<T>);\n        Postorder(NotoArbol<T>);\n}\ntemplate <class T>\nArbolBinario<T>::ArbolBinario(){\n    Raiz = nullptr;\n}\ntemplate <class T>\nvoid ArbolBinario<T>::CrearArbol(NotoArbol<T> *Apunt){\n    char Resp;\n    Apunt = new NodoArbol<T>;\n    cout<<\"Ingrese la información a almacenar\";\n    cin>>Apunt->Info;\n    cout<<\"Tiene un hijo izquierdo (S/N)\";\n    cin>>Resp;\n    if(Resp == 's'){\n        CrearArbol(Apunt->izq)\n        Apunt->izq = Raiz;\n    }\n\n    cout<<\"Tiene un hijo Derecho (S/N)\";\n    cin>>Resp;\n    if(Resp=='s'){\n        CrearArbol(Apunt->der)\n        Apunt->der = Raiz;\n    }\n    Raiz = Apunt;\n}\n\ntemplate <class T>\nvoid ArbolBinario<T>::Preorder(NotoArbol<T> *Apunt){\n    if(Apunt){\n        cout<<Apunt->info << \" \";\n        Preorder(Apunt->iza);\n        Preorder(Apunt->der);\n    }\n}\n\ntemplate <class T>\nvoid ArbolBinario<T>::Inorder(NotoArbol<T> *Apunt){\n    if(Apunt){\n        Inorder(Apunt->der);\n        cout<<Apunt->info << \" \";\n        Inorder(Apunt->iza);\n    }\n}\n\n\ntemplate <class T>\nvoid ArbolBinario<T>::Postorder(NotoArbol<T> *Apunt){\n    if(Apunt){\n        Postorder(Apunt->iza);\n        Postorder(Apunt->der);\n        cout<<Apunt->info << \" \";\n    }\n}\n"
              }
            ]
          }
        ]
      },
      {
        "title": "Grafos",
        "sources": "Data Structures and Algorithms in C++ 2e \nEstructura de datos orient ... uardati-FREELIBROS.ORG",
        "data": [
          {
            "subtitle": "",
            "body": "Un grafo en el ámbito de las ciencias de la computación es un tipo abstracto de datos (TAD), que consiste en un conjunto de nodos (también llamados vértices) y un conjunto de arcos (aristas) que establecen relaciones entre los nodos. El concepto de grafo TAD desciende directamente del concepto matemático de grafo.",
            "images": ["./assets/images/Matriz_de_adyacencia.jpg"],
            "code": [
              {
                "title": "Grafos ejemplo",
                "code": "#include <iostream> \n#include <cstdlib> \nusing namespace std; \n\nclass arista\n{\n    private:\n        arista *sig;\n        nodo *ady;\n        int peso;\n    public:\n\n        void setsig(arista*);\n        void setady(nodo*);\n        arista *getsig();\n        nodo *getady();\n        int getPeso();\n        arista();\n        ~arista();\n        friend class Grafo;\n\n};\n\narista::arista()\n{\n    arista = nullptr;\n    nodo = nullptr;\n    peso = 0;\n}\n\nvoid arista::setsig(arista *_sig){\n    sig=_sig;\n}\n\nvoid arista::setady(nodo *_ady){\n    ady=_ady;\n}\n\narista *arista::getsig(){\n    return sig;\n}\n\nnodo *arista::getady(){\n    return ady;\n}\n\nint arista::getPeso(){\n    return peso;\n}\n\n\nclass nodo{\n    private:\n        nodo *sig;\n        arista *ady;\n        carros dato;\n\n    public:\n\n        void setsig(nodo*);\n        void setady(arista*);\n        nodo *getsig();\n        arista *getady();\n        carros getdato();\n        nodo();\n        ~nodo();\n        friend class Grafo;\n\n};\n\nnodo::nodo(){\n    sig = nullptr;\n    ady = nullptr;\n    dato = nullptr;\n}\n\nvoid nodo::setsig(nodo *_sig){\n    sig=_sig;\n}\n\nvoid nodo::setady(arista *_ady){\n    ady=_ady;\n}\n\nnodo *nodo::getsig(){\n    return sig;\n}\n\narista *nodo::getady(){\n    return ady;\n}\n\ncarros nodo::getdato(){\n    return dato;\n}\n\nclass Grafo\n{\n    private:\n        nodo *h;\n\n    public:\n        Grafo();\n        ~Grafo();\n        void Inicializa();\n        bool Vacio();\n        int Tamano();\n        nodo *getvertice(string);\n        void InsertaArista(nodo *,nodo *,int);\n        void InsertaVertice(carros);\n        void ListaAdyacencia();\n        void ElimarArista(nodo*, nodo*);\n        void Anular();\n        void EliminarVertice(nodo*);\n        void guardargrafo();\n        void guardararistas();\n        void cargargrafo();\n        void cargararistas();\n};\n\n\nGrafo::Grafo()\n{\n    h = NULL;\n}\n\nvoid Grafo::Inicializa(){\n    h = NULL;\n}\n\nbool Grafo::Vacio(){\n    if(h == NULL){\n        return true;\n    }\n    return false;\n}\n\nint Grafo::Tamano(){\n    nodo *aux;\n    aux = h;\n    int cont = 0;\n    while(aux != NULL){\n        cont++;\n        aux = aux->sig;\n    }\n    return cont;\n}\n\nnodo *Grafo::getvertice(string nombre)\n{\n    nodo *aux;\n    aux = h;\n    while(aux != NULL){\n        if(aux->getdato().getnombre() == nombre){\n            return aux;\n        }\n        aux = aux->sig;\n    }\n    return NULL;\n}\n\nvoid Grafo::InsertaVertice(carros car){\n    nodo *nuevo = new nodo;\n    nuevo->dato = car;\n    nuevo->sig = NULL;\n    nuevo->ady = NULL;\n    if(Vacio()){\n        h = nuevo;\n    }\n    else{\n        nodo *aux;\n        aux = h;\n        while(aux->sig != NULL){\n            aux = aux->sig;\n        }\n        aux->sig = nuevo;\n    }\n}\n\nvoid Grafo::InsertaArista(nodo* origen,nodo* destino,int _peso){\n    arista *nueva = new arista;\n    nueva->peso = _peso;\n    nueva->sig = NULL;\n    nueva->ady = NULL;\n\n    arista *aux;\n    aux = origen->ady;\n    if(aux == NULL){\n        origen->ady = nueva;\n        nueva->ady = destino;\n    }\n    else{\n        while(aux->sig != NULL){\n            aux = aux->sig;\n        }\n        aux->sig = nueva;\n        nueva->ady = destino;\n    }\n}\n\nvoid Grafo::ListaAdyacencia(){\n    nodo *vertAux;\n    arista *arisAux;\n    vertAux = h;\n    while(vertAux != NULL){\n        cout << vertAux->getdato().getnombre() << \" -> \";\n        arisAux = vertAux->ady;\n        while(arisAux != NULL){\n            cout << arisAux->ady->getdato().getnombre() << \" -> \";\n            arisAux = arisAux->sig;\n        }\n        vertAux = vertAux->sig;\n        cout<<endl;\n    }\n}\n\nvoid Grafo::Anular(){\n    nodo *aux;\n    while(h != NULL){\n        aux = h;\n        h = h->sig;\n        delete aux;\n    }\n}\n\nvoid Grafo::ElimarArista(nodo *origen, nodo *destino){\n\n    arista *actual, *anterior;\n    actual = origen->getady();\n    int band=0;\n\n    if(actual == NULL){\n        cout << \"El vertice origen no tiene aristas\" << endl;\n    }\n    else if(actual->getady() == destino){\n        origen->ady = actual->sig;\n        delete actual;\n    }\n    else{\n        while(actual->ady != NULL){\n            if(actual->ady == destino){\n                band = 1;\n                anterior->sig = actual->sig;\n                delete actual;\n                break;\n            }\n            anterior = actual;\n            actual = actual->sig;\n        }\n        if(band == 0){\n            cout << \"Los vertices no estan conectados\" << endl;\n        }\n    }\n}\n\nvoid Grafo::EliminarVertice(nodo* cris){\n    nodo *actual, *anterior;\n    arista *aux;\n\n    actual = h;\n    while(actual != NULL){\n        aux = actual->getady();\n        while(aux != NULL){\n            if(aux->getady() == cris){\n                ElimarArista(actual, aux->getady());\n            }\n            aux = aux->getsig();\n        }\n        actual = actual->getsig();\n    }\n    actual = h;\n    if(h == cris){\n        h = h->getsig();\n        delete actual;\n    }\n    else{\n        while(actual != cris){\n            anterior = actual;\n            actual = actual->getsig();\n        }\n        anterior->setsig(actual->getsig());\n        delete actual;\n    }\n}\n\nvoid Grafo::guardargrafo() {\n  ofstream Ponle;\n  nodo* aux = h;\n\n  Ponle.open(\"file01.txt\", Ponle.trunc);\n\n  while(aux != nullptr) {\n    Ponle << aux->getdato();\n    aux = aux->getsig();\n  }\n\n  Ponle.close();\n}\n\nvoid Grafo::guardararistas(){\n    ofstream Ponle;\n    nodo* verAux;\n    arista* arisAux;\n    verAux = h;\n\n    Ponle.open(\"file02.txt\", Ponle.trunc);\n    while(verAux != nullptr) {\n        if(verAux->getady() != nullptr) {\n            Ponle << verAux->getdato().getnombre() << \"|\";\n        }\n        arisAux = verAux->getady();\n        while(arisAux != nullptr) {\n            Ponle << arisAux->getady()->getdato().getnombre() << \"|\" << arisAux->getPeso() << \"*\";\n            if(arisAux->getsig() != nullptr) {\n                Ponle<< verAux->getdato().getnombre() << \"|\" ;\n            }\n            arisAux = arisAux->getsig();\n        }\n        Ponle << \"\n\";\n        verAux = verAux->getsig();\n\n    }\n    Ponle.close();\n}\n\n\nvoid Grafo::cargargrafo() {\n  ifstream archivo;\n    int peso;\n    carros cars;\n\n            archivo.open(\"file01.txt\", ios::in);\n            if(!archivo)\n            {\n                cerr << \"No se pudo abrir el archivo\" << endl;\n                exit(1);\n            }\n            else\n            {\n                archivo.clear();\n                archivo.seekg(0,ios::beg);\n                string nom,mar,velmax;\n\n                while(true){\n                    getline(archivo, nom, '|');\n                    cars.setnombre(nom);\n                    if(archivo.eof()){\n                        break;\n                    }\n                    getline(archivo, mar, '|');\n                    cars.setmarca(mar);\n                    getline(archivo, velmax, '*');\n                    peso=stoi(velmax);\n                    cars.setvelocidad(peso);\n                    InsertaVertice(cars);\n                }\n                cout<<\"datos cargados correctamente\"<<endl;\n            }\n            archivo.close();\n}\n\nvoid Grafo::cargararistas(){\n    ifstream archivo;\n    int peso;\n            archivo.open(\"file02.txt\", ios::in);\n            if(!archivo)\n            {\n                cerr << \"No se pudo abrir el archivo\" << endl;\n                exit(1);\n            }\n            else\n            {\n                archivo.clear();\n                archivo.seekg(0,ios::beg);\n                string nom,mar,velmax;\n\n                while(true){\n                    getline(archivo, nom, '|');\n                    if(archivo.eof()){\n                        break;\n                    }\n                    getline(archivo, mar, '|');\n                    getline(archivo, velmax, '*');\n                    peso=stoi(velmax);\n                    InsertaArista(getvertice(nom),getvertice(mar),peso);\n                }\n                cout<<\"datos cargados correctamente\"<<endl;\n            }\n            archivo.close();\n}"
              }
            ]
          }
        ]
      }
]